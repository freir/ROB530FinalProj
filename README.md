# Wheel Slip DRIFT: Dead Reckoning In Field Time with Wheel Slip Considerations

## Description
We have augmented the original DRIFT library to consider wheel slip when dead reckoning to track location for a 4 wheeled robot. We have configured the DRIFT algorithm to work using TartanDrive data as the inputs for the InEKF.

The ```tartan.cpp``` file is copied from the example ```neya.cpp```, another atv, with some adjustments to accept the correct message types for the TartanDrive ATV and for the differing vehicle dimensions.  

Additionally, there was a problem in TartanDrive's dataset where the .msg files they provide do not match the .msg files that were referenced when the rosbags were recorded, leading to the same variable names and fields for ```rp_wheel_encoders.msg``` but different MD5 checksums. Therefore, it is impossible to subscribe to that topic without the checksums. To get around this, we created ```drift/wheel_rpm_resubscriber/publish_wheel_encoders.py```, a function that reads the timestep from a standard message type during rosbag playback and publishes the wheel encoder readings in an ```racepak/rp_wheel_encoders``` object by reading from a .csv file. 

The TartanDrive dataset can be installed using the [TartanDrive repo](https://github.com/castacks/tartan_drive) with some additional steps:

Please follow the TartanDrive repo instructions to download the correct data. For our code, we use the examples from the September 10th code, since they are the most intense driving trajectories. Once rosbags are downloaded, you do not need to convert them to .plt files. If you would like to use different trajectories, you will need to convert those Rosbag files from tartanDrive into .csv files and store them in /drift/wheel_rpm_resubscriber_csv0910_wheel_rpm/ for the resubcriber node to read. 

While following the TartanDrive instructions, it is important to create a catkin_ws/ with the custom message types in the same directory as the main drift/ directory, due to ```publish_wheel_encoders.py```. Then source the ```catkin_ws/devel/setup.bash``` within your terminal. 

The original DRIFT readme can be followed, replacing the run command with:
```
rosrun drift tartan
```

In order to run our full pipeline, you will need four terminals open:
1) Run roscore
2) python3 publish_wheel_encoders.py
3) rosrun drift tartan
4) rosbag play \<TartanDrive file>.bag --clock

The code is currently configured to run the 0th trial from September 10th. In order to change the trial to run, you need to

1) Update publish_wheel_encoders.py to read from the correct CSV
2) (OPTIONAL) Change ```drift/config/tartan/inekf_estimator.yaml``` to save the logs to .txt files with accurate filenames
3) Run the correct Rosbag
4) Redo steps 2-4 in the four terminal instructions

## New scripts:
scripts/Analyze_wheel_rpm_data.vb: Microsoft excel macro for analyzing wheel_rpm csvs generated by running the rosbags through https://github.com/AtsushiSakai/rosbag_to_csv and selecting the wheel_rpm topic. The macro calculates the frequency of a wheel having a speed >15% above or below the median wheel speed at a given time step, and plots wheel speed and the range of wheel speeds at each time step.

scripts/CompareTrajectories.m was not used, instead https://github.com/MichaelGrupp/evo/wiki/evo_traj was used to plot and compare trajectories

scripts/RBT_DRIFT_output_trajectory.m is a MATLAB script used to take the .txt files that are output by DRIFT (in the tum format described in evo_traj) and perform a rigid body transformation to align them with the ground truth frame.



# ****** Original DRIFT README ******
Dead Reckoning In Field Time (DRIFT) is an open-source C++ software library designed to provide accurate and high-frequency proprioceptive state estimation for a variety of mobile robot architectures. By default, DRIFT supports legged robots, differential-drive wheeled robots, full-size vehicles with shaft encoders and marine robots with a Doppler Velocity Log (DVL). Leveraging symmetry-preserving filters such as [Invariant Kalman Filtering (InEKF)](https://www.annualreviews.org/doi/10.1146/annurev-control-060117-105010), this modular library empowers roboticists and engineers with a robust and adaptable tool to estimate instantaneous local pose and velocity in diverse environments. The software is structured in a modular fashion, allowing users to define their own sensor types, and propagation and correction methods, offering a high degree of customization.

Detailed documentations and tutorials can be found at [https://umich-curly.github.io/DRIFT_Website/](https://umich-curly.github.io/DRIFT_Website/).

## Framework
![flow_chart](figures/flow_chart.jpg?raw=true "flow chart")

## Run Time Analysis
We perform runtime evaluations using a personal laptop with an Intel i5-11400H CPU and an NVIDIA Jetson AGX Xavier (CPU). DRIFT can operate at an extremely high frequency using CPU-only computation, even on the resourced-constrained Jetson AGX Xavier. For the optional contact estimator, the inference speed on an NVIDIA RTX 3090 GPU is approximately 1100 Hz, and the inference speed on a Jetson AGX Xavier (GPU) is around 830 Hz after TensorRT optimization.

![run_time](figures/run_time.png?raw=true "run time")

# Dependencies
We have tested the library in **Ubuntu 20.04** and **22.04**, but it should be easy to compile in other platforms.

> ### C++17 Compiler
We use the threading functionalities of C++17.


> ### Eigen3
Required by header files. Download and install instructions can be found at: http://eigen.tuxfamily.org. **Requires at least 3.1.0**.

> ### Yaml-cpp
Required by header files. Download and install instructions can be found at: https://github.com/jbeder/yaml-cpp.

> ### ROS1 (Optional)
Building with ROS1 is optional. Instructions are [found below](https://github.com/UMich-CURLY/drift/tree/main#4-ros).

# Building DRIFT library

Clone the repository:
```
git clone https://github.com/UMich-CURLY/drift.git
```
Create another directory which we will name 'build' and use cmake and make to compile an build project:

```
mkdir build
cd build
cmake ..
make -j4
```

## Install the library
After building the library, you can install the library to the system. This will allow other projects to find the library without needing to specify the path to the library. 

```
sudo make install
```
Then, you can include the library in your project by adding the following line to your CMakeLists.txt file:
```
find_package(drift REQUIRED)
```

# ROS
## Examples
We provide several examples in the `ROS/examples` directory. 

## Building the ROS1 node
1. Add `/ROS/drift` to the `ROS_PACKAGE_PATH` environment variable. Open your ~/.bashrc file in a text editor and add the following line to the end. Replace PATH/TO with the directory path to where you cloned drift:

  ```
  export ROS_PACKAGE_PATH=${ROS_PACKAGE_PATH}:PATH/TO/drift/ROS/drift
  ```

  Then
  ```
  source ~/.bashrc
  ```
  
2. Execute `build_ros.sh` script in the repository root directory:

  ```
  cd <PATH>/<TO>/drift
  chmod +x build_ros.sh
  ./build_ros.sh
  ```

## Run examples
**Clearpath Husky robot:**
```
rosrun drift husky
```

**Fetch robot with the gyro filter:**
```
rosrun drift fetch
```

**Full-size vehicle:**
```
rosrun drift neya
```

**MIT mini-cheetah robot:**
```
rosrun drift mini_cheetah
```

**Girona500 (Marine robot):**
```
rosrun drift girona500
```

## Run the repo with your own robots:
Please refer to the tutorial here: https://umich-curly.github.io/DRIFT_Website/tutorials/.

# Contact Estimation
The contact estimation and the contact data set can be found in https://github.com/UMich-CURLY/deep-contact-estimator.

# Citations
If you find this work useful, please kindly cite the following papers

* Tzu-Yuan Lin, Tingjun Li, Wenzhe Tong, and Maani Ghaffari. "Proprioceptive Invariant Robot State Estimation." arXiv preprint arXiv:2311.04320 (2023). (Under review for Transaction on Robotics)
```
@article{lin2023proprioceptive,
  title={Proprioceptive Invariant Robot State Estimation},
  author={Lin, Tzu-Yuan and Li, Tingjun and Tong, Wenzhe and Ghaffari, Maani},
  journal={arXiv preprint arXiv:2311.04320},
  year={2023}
}
```
* Tzu-Yuan Lin, Ray Zhang, Justin Yu, and Maani Ghaffari. "Legged Robot State Estimation using Invariant Kalman Filtering and Learned Contact Events." In Conference on robot learning. PMLR, 2021
```
@inproceedings{
   lin2021legged,
   title={Legged Robot State Estimation using Invariant Kalman Filtering and Learned Contact Events},
   author={Tzu-Yuan Lin and Ray Zhang and Justin Yu and Maani Ghaffari},
   booktitle={5th Annual Conference on Robot Learning },
   year={2021},
   url={https://openreview.net/forum?id=yt3tDB67lc5}
}
```

# License
DRIFT is released under a [BSD 3-Clause License](https://github.com/UMich-CURLY/drift/blob/main/LICENSE). 
